from xbmctorrent import plugin
from xbmctorrent.scrapers import scraper
from xbmctorrent.ga import tracked
from xbmctorrent.caching import cached_route
from xbmctorrent.utils import ensure_fanart


BASE_URL = "%s/" % plugin.get_setting("base_kickass")
HEADERS = {
    "Referer": BASE_URL,
}
CATEGORIES = [
    ("Audio", 100, [
        ("Music", 101),
        ("Audio Books", 102),
        ("Sound clips", 103),
        ("FLAC", 104),
        ("Other", 199),
    ]),
    ("Video", 200, [
        ("Movies", 201),
        ("Movies DVDR", 202),
        ("Music videos", 203),
        ("Movie clips", 204),
        ("TV shows", 205),
        ("Handheld", 206),
        ("HD - Movies", 207),
        ("HD - TV shows", 208),
        ("3D", 209),
        ("Other", 299),
    ]),
    ("Porn", 500, [
        ("Movies", 501),
        ("Movies DVDR", 502),
        ("HD - Movies", 503),
        ("Movie clips", 504),
        ("Other", 599),
    ]),
]
# Cache TTLs
DEFAULT_TTL = 24 * 3600 # 24 hours


def find_imdb_id(soup):
    import re
    from xbmctorrent.utils import first

    imdb_node = first(soup.find_all("a", href=re.compile("imdb")))
    if imdb_node:
        result = re.search(r".*(tt\d+).*", imdb_node["href"])
        if result:
            return result.group(1)


def get_torrent_info(url):
    from bs4 import BeautifulSoup
    from xbmctorrent.utils import first, url_get

    response = url_get(url, headers=HEADERS)
    soup = BeautifulSoup(response, "html5lib")
    movie = first(soup.select('td[itemtype="http://schema.org/Product"] div.font11px a[href="/movies/"]')) is not None
    serie = first(soup.select('td[itemtype="http://schema.org/Product"] div.font11px a[href="/tv/"]')) is not None

    def itemprop(prop, default=None):
        node = first(soup.select('[itemprop="%s"]' % prop))
        return node and node.text or default
    def itemprops(prop, default=[]):
        nodes = soup.select('[itemprop="%s"]' % prop)
        return [node.text for node in nodes] or default

    return {
        "movie": movie and not serie,
        "serie": serie and not movie,
        "seeders": itemprop("seeders"),
        "leechers": itemprop("leechers"),
        "title": itemprop("name"),
        "quality": itemprop("quality"),
        "genres": itemprops("genre"),
        "magnet_url": first(soup.select(".magnetlinkButton"))["href"],
        "poster": first(soup.select('a.movieCover img'), {}).get("href"),
        "cast": [cast.text for cast in soup.select('[itemprop="name"] a')],
        "imdb_id": find_imdb_id(soup),
    }


@scraper("Kickass Torrents - Movies and Series", "%s/content/images/logos/kickasstorrents_500x500.png" % BASE_URL, plugin.get_setting("kickass_enabled", bool))
@plugin.route("/kickass")
@ensure_fanart
@tracked
def kickass_index():
    return [
        {"label": "Movies", "path": plugin.url_for("kickass_page", root="movies", page=1, content_type="movies")},
        {"label": "Search", "path": plugin.url_for("kickass_search")},
    ]


@plugin.route("/kickass/<root>/<page>")
@cached_route(ttl=DEFAULT_TTL, content_type="movies")
@ensure_fanart
@tracked
def kickass_page(root, page):
    import re
    import xbmc
    import xbmcgui
    from bs4 import BeautifulSoup
    from contextlib import closing
    from concurrent import futures
    from urlparse import urljoin
    from xbmctorrent import tmdb
    from xbmctorrent.utils import first, terminating, url_get, get_quality_from_name

    content_type = first(plugin.request.args.get("content_type")) or None
    if content_type:
        plugin.set_content(content_type)

    page = int(page)
    page_data = url_get(urljoin(BASE_URL, "%s/%d" % (root, page)), headers=HEADERS)
    soup = BeautifulSoup(page_data, "html5lib")
    torrent_nodes = [node.parent for node in soup.findAll("td", "torrentnameCell")]

    def _get_torrent_info_with_meta(url):
        torrent_info = get_torrent_info(url)
        if torrent_info["movie"] and torrent_info["imdb_id"]:
            torrent_info["tmdb"] = tmdb.get(torrent_info["imdb_id"])
        return torrent_info


    with closing(xbmcgui.DialogProgress()) as dialog:
        dialog.create(plugin.name)
        dialog.update(percent=0, line1="Fetching torrent information...", line2="", line3="")

        state = {"done": 0}
        def on_torrent(future):
            data = future.result()
            state["done"] += 1
            dialog.update(
                percent=int(state["done"] * 100.0 / len(torrent_nodes)),
                line2=data.get("title") or "",
            )

        with futures.ThreadPoolExecutor(max_workers=3) as pool:
            movies = []
            for node in torrent_nodes:
                info_nodes = node.findAll("td")
                a_node = first(info_nodes[0].select("div.torrentname a.plain"))
                movies.append(pool.submit(_get_torrent_info_with_meta, urljoin(BASE_URL, a_node["href"])))
            [future.add_done_callback(on_torrent) for future in movies]
            while not all(job.done() for job in movies):
                if dialog.iscanceled():
                    return
                xbmc.sleep(100)

    movies = [movie.result() for movie in movies]
    for i, movie in enumerate(movies):
        if movie.get("tmdb"):
            item = tmdb.get_list_item(movie["tmdb"])
            proper_kat_title = re.sub("\s+", " ", re.sub(r"[().-]", " ", movie["title"]))
            item["label"] = "%s (%s)" % (item["label"], re.sub(r"(?i)%s" % item["label"], "", proper_kat_title).strip())
        else:
            item = {
                "label": movie["title"],
                "info": {
                    "genre": ", ".join(movie["genres"]),
                }
            }
        lower_title = movie["title"].lower()
        if "x264" in lower_title:
            item.setdefault("stream_info", {})["codec"] = item.setdefault("info", {})["video_codec"] = "h264"
        if "xvid" in lower_title:
            item.setdefault("stream_info", {})["codec"] = item.setdefault("info", {})["video_codec"] = "xvid"
        if "720p" in lower_title:
            item.setdefault("stream_info", {}).update({
                "width": 1280,
                "height": 720,
            })
        if "1080p" in lower_title:
            item.setdefault("stream_info", {}).update({
                "width": 1920,
                "height": 1080,
            })
        item.update({
            "path": plugin.url_for("play", uri=movie["magnet_url"]),
            "is_playable": True,
        })
        item.setdefault("info", {}).update({
            "count": i,
            "genre": "%s (S:%s P:%s)" % (item.get("info", {}).get("genre") or "", movie["seeders"], movie["leechers"]),
        })
        item.setdefault("stream_info", {}).update({
            "video": get_quality_from_name(movie["title"]),
        })
        yield item
    yield {
        "label": "Next page...",
        "path": plugin.url_for("kickass_page", root=root, page=page + 1, content_type=content_type),
    }


@plugin.route("/kickass/search")
@tracked
def kickass_search():
    import urllib

    query = plugin.request.args.get("query")
    if query:
        query = query[0]
    else:
        query = plugin.keyboard("", "XBMCtorrent - Kickass Torrent - Search")
    if query:
        plugin.redirect(plugin.url_for("kickass_page", root="usearch/%s/" % urllib.quote(query), page=0))
